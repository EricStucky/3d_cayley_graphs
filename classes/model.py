
# This file was *autogenerated* from the file model.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_5 = Integer(5); _sage_const_0p75 = RealNumber('0.75'); _sage_const_10 = Integer(10); _sage_const_0p5 = RealNumber('0.5'); _sage_const_20 = Integer(20)# import sys
# import re

def three_tuple(tup):
  new_tup = ()
  if len(tup) == _sage_const_1 :
    return tup + (_sage_const_0 , _sage_const_0 )
  elif len(tup) == _sage_const_2 :
    return tup + (_sage_const_0 ,)
  else:
    return tup

class ReflectionGroupModel:
    def __init__(self):
        # self.points = null
        # self.edges = null
        # self.faces = null
        self.W = -_sage_const_1 
        self.form = "" # TODO field!!
        self.real = True
        self.rank = -_sage_const_1 
        self.reflections = []

        self.model = -_sage_const_1 
        self.my_point = ()
        self.projection_vector = ()
        self.reflection_colors = {}
        self.reflection_edges = {}
        self.points = {}
        self.model_reflections = []
        self.lie_type = "none"

        self.code = ""
        self.obj = ""

    # what to actually pass in here???
    def setGroup(self, group, point):
        # need error checking
        self.W = group
        self.my_point = point
        self.form = str(group).split()[_sage_const_1 ]
        self.real = group.is_real()
        self.rank = group.rank()
        self.reflections = group.reflections()
        self.lie_type = group.cartan_type()[_sage_const_0 ]

    def printGroup(self):
        print self.W
        print self.form
        print self.real
        print self.rank
        print self.reflections

    def canPrint(self):
        if self.W.subgroup(self.model_reflections).is_isomorphic(self.W):
            return True
        else:
            return False

    def create(self):
        self.setModel()
        if self.real == True:
            self.buildRealModel()
        else:
            self.buildComplexModel()
    def showModel(self):
        self.model.show(viewer="threejs")

    def buildRealModel(self):
        #silly to have these here, fix later
        def all_points(W, points, the_object):
          for r3 in self.W:
            key = "w" + str(r3.reduced_word())
            if points[key] == True:
              the_object += sphere(self.points[r3],_sage_const_1 ,color='gray')
          return the_object

        def outside_edge_list(W, the_object, Points_as_vertices, Labeled_by_reflections_colors):
          outside_edges = {}
          for r in self.W.simple_reflections():
              pairs = []
              for w2 in W:
                single_edge = [w2.reduced_word(), (r*w2).reduced_word()]
                if [(r*w2).reduced_word(), w2.reduced_word()] not in pairs:
                  pairs.append(single_edge)
              outside_edges[r] = pairs

          if outer_edges == True:
            for r in W.simple_reflections():
              for x in outside_edges[r]:
                the_object += line3d([tuple(self.points[W.from_reduced_word(x[_sage_const_0 ])]), tuple(self.points[W.from_reduced_word(x[_sage_const_1 ])])], opacity=_sage_const_1 , radius=_sage_const_0p75 ,color = Color(Labeled_by_reflections_colors[r]))
          return the_object

        the_object = line3d([(_sage_const_0 ,_sage_const_0 ,_sage_const_0 ),(_sage_const_0 ,_sage_const_0 ,_sage_const_0 )])
        # if False: #simple_refls == True:
        #     for r2 in W.simple_reflections():
        #         key = "r" + str(r2.reduced_word())
        #         if refls[key] == True:
        #           for x in Labeled_by_reflections_Spline_Edges[r2]:
        #               the_object += line3d([tuple(Points_as_vertices[W.from_reduced_word(x[0])]), tuple(Points_as_vertices[W.from_reduced_word(x[1])])], opacity=0.5, radius=0.5,color = Color(Labeled_by_reflections_colors[r2]))
        # else:
        for r in self.reflections:
            key = "r" + str(r.reduced_word())
            #refls[key] = True ### TODO debug
            if True: #refls[key] == True:
              for x in self.reflection_edges[r]:
                  the_object += line3d([tuple(self.points[self.W.from_reduced_word(x[_sage_const_0 ])]), tuple(self.points[self.W.from_reduced_word(x[_sage_const_1 ])])], opacity=_sage_const_0p5 , radius=_sage_const_0p5 ,color = Color(self.reflection_colors[r]))
        #the_object = all_points(W, points, self.points, the_object)
        #the_object = outside_edge_list(self.W, the_object, self.points, self.reflection_colors)
        if True: #start == True: #TODO user input
          the_object += sphere(three_tuple(self.my_point), _sage_const_1 , color='black')
          self.model = the_object

    def buildComplexModel(self):
        the_object = Polyhedron(vertices=[[_sage_const_0 ,_sage_const_0 ,_sage_const_0 ]]).projection().render_solid_3d()
        counter = _sage_const_0 
        for r in W.reflections():
            for x in Labeled_by_reflections_Spline_Edges[r]:
                refl_verts = []
                for i in range(r.order()):
                    refl_verts.append(list(three_d_points[W.from_reduced_word(x[i])]))
                # print refl_verts
                the_object += Polyhedron(vertices=refl_verts).projection().render_solid_3d(color=Color(Labeled_by_reflections_colors[r]))
                counter += _sage_const_1 
                print counter

    def setModel(self):
        if self.real == True:
            self.setRealModel()
        else:
            self.setComplexModel()

    def setComplexModel(self):
        RainBow = rainbow(len(list(self.reflections)))
        my_index = _sage_const_0 
        for r in self.W.reflections:
            self.reflection_colors[r] = RainBow[my_index]
            my_index = my_index+_sage_const_1 
            reflection_loops = []
            group_elements_list = W.list()
            for w in self.W:
                if w in group_elements_list:
                    my_hyper_edge = []
                    for i in range(r.order()):
                        group_elements_list.remove(r**i*w)
                        my_hyper_edge.append((r**i*w).reduced_word())
                    reflection_loops.append(my_hyper_edge)
            self.reflection_edges[r] = reflection_loops

        As_4D_Real_Points = {}
        for w in self.W:
            a = CC(vector(w.matrix()*vector(self.my_point))[_sage_const_0 ]).real()
            b = CC(vector(w.matrix()*vector(self.my_point))[_sage_const_0 ]).imag()
            c = CC(vector(w.matrix()*vector(self.my_point))[_sage_const_1 ]).real()
            d = CC(vector(w.matrix()*vector(self.my_point))[_sage_const_1 ]).imag()
            new_point_4d = vector((a,b,c,d))
            As_4D_Real_Points[w] = new_point_4d

        n = vector((_sage_const_1 ,-_sage_const_1 ,_sage_const_1 ,-_sage_const_1 )).normalized()# this is the normal vector to whatever hyperplane we are using to project from 4D to 3D. We will want to be able to change this to find a "pretty" projection.
        points_in_hyperplane = {}
        for w in self.W:
            v = vector(As_4D_Real_Points[w])
            projected_point = v - v.dot_product(n)*n
            points_in_hyperplane[w] = projected_point

        self.points = {}
        for w in self.W:
            v = points_in_hyperplane[w]
            a = v[_sage_const_0 ]
            b = v[_sage_const_1 ]
            c = v[_sage_const_2 ]
            self.points[w] = (_sage_const_10 *a,_sage_const_10 *b,_sage_const_10 *c)

    def setRealModel(self):
        print "lie", self.lie_type
        mirror_vectors = []
        if self.lie_type == "A": # TODO assign lie type
          mirrors = [(_sage_const_0 ,_sage_const_1 ,-_sage_const_1 ), (_sage_const_1 ,-_sage_const_1 ,_sage_const_0 ), (_sage_const_0 ,_sage_const_1 ,_sage_const_1 )]  ## this is special for this group, sub in matrix manipulation for general/complex refl.
          for v in mirrors:
              mirror_vectors.append(vector(v).normalized())
        elif self.lie_type == "B":
          mirrors = [(_sage_const_1 ,-_sage_const_1 ,_sage_const_0 ), (_sage_const_0 ,_sage_const_1 ,-_sage_const_1 ),(_sage_const_0 ,_sage_const_0 ,_sage_const_1 )]  ## this is special for this group, sub in matrix manipulation for general/complex refl.
          for v in mirrors:
              mirror_vectors.append(vector(v).normalized())

        # print g_lie_type, mirror_vectors

        List_of_Points = []
        if self.lie_type == "A":
          for w1 in self.W:
              if len(w1.reduced_word()) == _sage_const_0 :
                  List_of_Points.append(self.my_point) #vector(three_tuple(tuple(my_point)))) ## TODO trying to make 2D???
              else:
                  #   new_point = vector(three_tuple(tuple(my_point))) # (a,b,c)
                  #   print "this", a,b,c
                  #   new_point = (a,b,c)
                  new_point = self.my_point
                  for i in Sequence(ellipsis_iter(_sage_const_1 ,Ellipsis,len(w1.reduced_word()))):
                      new_point = reflect_across(new_point,vector(mirror_vectors[w1.reduced_word()[i-_sage_const_1 ]-_sage_const_1 ]))
                  List_of_Points.append(new_point)
                #   print new_point
        if self.lie_type == "B":
          for w in self.W:
            print "point", self.my_point
            self.my_point = (_sage_const_20 , _sage_const_10 )
            print vector(self.my_point)
            new_point = vector(self.my_point) * w.matrix()
            List_of_Points.append(vector(three_tuple(tuple(new_point))))

        for j in range(len(list(self.W))):
            print List_of_Points, list(self.W), j
            self.points[self.W[j]] = List_of_Points[j]

        RainBow = rainbow(len(self.reflections))
        my_index = _sage_const_0 
        for r in self.reflections:
            self.reflection_colors[r] = RainBow[my_index]
            my_index = my_index+_sage_const_1 
            pairs = []
            for w in self.W:
                single_edge = [w.reduced_word(), (w*r).reduced_word()]
                if [(w*r).reduced_word(), w.reduced_word()] not in pairs:
                    pairs.append(single_edge)
            self.reflection_edges[r] = pairs

    ###  Export related
    def writeOpenSCADCode(self):
        for r in self.W.reflections():
            for x in Labeled_by_reflections_Spline_Edges[r]:
                string = "{color(" + str(list(Color(Labeled_by_reflections_colors[r]).rgb())) + ")hull(){"
                for i in range(r.order()):
                    substring = "translate(" + str(list(three_d_points[W.from_reduced_word(x[i])] )) + ")sphere(r=.15);"
                    self.code += substring
                end = "}}"
                self.code += end

    def setOpenSCADDiv(self):
        # Print html with at least one character escaped,
        # for Firefox compatibility
        pretty_print(html('&lt;div id=scad hidden>'+self.code+"&lt;/div>"))

    def writeObj(self):
        self.obj = self.model.obj()


def reflectionGroupTests():
    test = ReflectionGroupModel()
    test.printGroup()
    W = ReflectionGroup(['B',_sage_const_2 ])
    #W = ReflectionGroup((2,2,2))
    test.setGroup(W, (_sage_const_20 ,_sage_const_10 ,_sage_const_5 ))
    test.printGroup()
    test.create()
    test.showModel()

    # test2 = ReflectionGroupModel()
    # WW = ReflectionGroup((2,1,3))
    # test2.setGroup(WW, (20,10,5))
    # test2.printGroup()
    # test2.create()

#reflectionGroupTests()

